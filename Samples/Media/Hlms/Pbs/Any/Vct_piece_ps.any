
@property( vct_num_probes )

@piece( DeclVctTextures )
	@property( syntax == glsl )
		uniform sampler3D vctProbe;
	@end
	@property( syntax == hlsl )
		Texture3D vctProbe				: register(t@value(vctProbe));
		SamplerState vctProbeSampler	: register(s@value(vctProbe));
	@end
	@property( syntax == metal )
		, texture3d<float> vctProbe		[[texture(@value(vctProbe))]]
		, sampler vctProbeSampler		[[sampler(@value(vctProbe))]]
	@end
@end

@piece( DeclVctFuncs )
	/// Generates a TBN matrix when no tangent information is present using
	/// DDX information.
	/// Should only we used as a fallback as the result isn't fully stable due to how DDX works
	/// and due to floating point precision. It is possible for the TBN to change as you zoom-in
	/// to the triangle.
	float3x3 generateTbn( float3 geomNormal, float3 pos )
	{
		float3 tangentX = OGRE_ddx( pos.xyz ).xyz;
		tangentX = normalize( tangentX );

		float3 binormal = cross( geomNormal, tangentX ) ;
		float3x3 TBN = buildFloat3x3( tangentX, binormal, geomNormal );
		return TBN;
	}

	float3 voxelConeTrace( VctProbeParams probeParams, float3 posLS, float3 ambient,
						   float3 dirLS, float tanHalfAngle,
						   sampler3D probe
						   OGRE_SAMPLER_ARG_DECL( probeSampler ) )
	{
		float dist = probeParams.vctStartBias;
		float alpha = 0.0;
		float3 color = float3( 0.0, 0.0, 0.0 );

		while( dist < probeParams.vctMaxDistance && alpha < 0.95 )
		{
			float diameter = max( 1.0, 2.0 * tanHalfAngle * dist );
			float4 scolor = OGRE_SampleLevel( probe, probeSampler,
											  (posLS + dist * dirLS) * probeParams.vctCellSize,
											  log2(diameter) );
			float a = (1.0f - alpha);
			color += scolor.xyz * a;
			alpha += a * scolor.w;
			dist += diameter * 0.5f;
		}

		if( probeParams.vctBlendAmbient != 0 )
			color.xyz = lerp( ambient, color.xyz, min(1.0, alpha / 0.95) );

		return color;
	}

	float3 toVctProbeSpacePos( float3 pos, VctProbeParams probeParams )
	{
		float3 posLS;
		posLS.x = dot( probeParams.xform_row0.xyzw, float4( pos, 1.0 ) );
		posLS.y = dot( probeParams.xform_row1.xyzw, float4( pos, 1.0 ) );
		posLS.z = dot( probeParams.xform_row2.xyzw, float4( pos, 1.0 ) );
		return posLS;
	}

	float3 toVctProbeSpaceDir( float3 dir, VctProbeParams probeParams )
	{
		float3 dirLS;
		dirLS.x = dot( probeParams.xform_row0.xyz, dir );
		dirLS.y = dot( probeParams.xform_row1.xyz, dir );
		dirLS.z = dot( probeParams.xform_row2.xyz, dir );
		return dirLS;
	}

	#define M_PI 3.141592654f

	void computeVctProbe
	(
		OGRE_OUT_REF( float3, outDiffuse ), OGRE_OUT_REF( float4, outSpecular ),
		PixelData pixelData, float3 pos, float3x3 TBN, float3 ambientUpperHemi,
		VctProbeParams probeParams,
		sampler3D probe OGRE_SAMPLER_ARG_DECL( probeSampler )
	)
	{
		float3 posLS = toVctProbeSpacePos( pos + pixelData.geomNormal.xyz * probeParams.vctNormalBias,
										   probeParams );
		float3 reflVecLS = toVctProbeSpaceDir( pixelData.reflDir, probeParams );

		if( posLS.x < 0.0 || posLS.x > 1.0 ||
			posLS.y < 0.0 || posLS.y > 1.0 ||
			posLS.z < 0.0 || posLS.z > 1.0 )
		{
			outDiffuse = float3( 0, 0, 0 );
			outSpecular = float4( 0, 0, 0, 0 );
			return;
		}

		@property( vct_num_probes > 1 )
			float3 blendv = abs( posLS * 2.0f - 1.0f );
			float blend = saturate( 1.0f - max3( blendv.x, blendv.y, blendv.z ) );
		@else
			float blend = 0.0f;
		@end

		@property( vct_cone_dirs == 6 )
			float3 cone_dirs[6] =
				FLOAT3_ARRAY_START
					float3( 0.0, 0.0, 1.0 ),
					float3( 0.866025, 0.0, 0.5 ),
					float3( 0.267617, 0.823639, 0.5 ),
					float3( -0.700629, 0.509037, 0.5 ),
					float3( -0.700629, -0.509037, 0.5 ),
					float3( 0.267617, -0.823639, 0.5 )
				OGRE_ARRAY_END;

			float coneWeights[6] = FLOAT_ARRAY_START 0.25, 0.15, 0.15, 0.15, 0.15, 0.15 OGRE_ARRAY_END;
			float coneAngleTan = 0.577;
			float minRefTan = 0.0;
		@else
			float3 cone_dirs[4] =
				FLOAT3_ARRAY_START
					float3( 0.707107, 0.0, 0.707107 ),
					float3( 0.0, 0.707107, 0.707107 ),
					float3( -0.707107, 0.0, 0.707107 ),
					float3( 0.0, -0.707107, 0.707107 )
				OGRE_ARRAY_END;

			float coneWeights[4] = FLOAT_ARRAY_START 0.25, 0.25, 0.25, 0.25 OGRE_ARRAY_END;
			float coneAngleTan = 0.98269;
			//max_distance *= 0.5;
			float minRefTan = 0.2;
		@end

		//Radiance / diffuse
		float3 light = float3( 0.0f, 0.0f, 0.0f );
		for( int i=0; i<@value( vct_cone_dirs ); ++i )
		{
			float3 dir = toVctProbeSpaceDir( mul( TBN, cone_dirs[i] ), probeParams );
			dir = normalize( dir );
			//TODO: There are better values than passBuf.ambientUpperHemi. When VCT probe can be used
			//then we should not apply BRDF_EnvMap and use the values in pixelData.envColourD
			light += coneWeights[i] * voxelConeTrace( probeParams, posLS, ambientUpperHemi, dir,
													  coneAngleTan,
													  probe OGRE_SAMPLER_ARG( probeSampler ) );
		}

		outDiffuse += light * (probeParams.vctBlendFade * blend);

		//Irradiance / specular
		//TODO: There are better values than passBuf.ambientUpperHemi. When VCT probe can be used
		//then we should not apply BRDF_EnvMap and use the values in pixelData.envColourS
		float3 irrLight = voxelConeTrace( probeParams, posLS, ambientUpperHemi, reflVecLS,
										  max( minRefTan, tan( pixelData.roughness * 0.5f *
															   M_PI * 0.99f ) ),
										  probe OGRE_SAMPLER_ARG( probeSampler ) );
		outSpecular += float4( irrLight * (probeParams.vctBlendFade * blend), blend );
	}
@end

@piece( applyVoxelConeTracing )
	@property( !normal_map )
		float3x3 TBN = generateTbn( pixelData.geomNormal, inPs.pos );
	@end

	@property( ambient_hemisphere || ambient_fixed || envmap_scale )
		float3 vctAmbient = passBuf.ambientUpperHemi;
	@else
		float3 vctAmbient = float3( 0, 0, 0 );
	@end

	float3 vctDiffuse;
	float4 vctSpecular;
	computeVctProbe( vctDiffuse, vctSpecular, pixelData, inPs.pos, TBN,
					 vctAmbient, passBuf.vctProbeParams,
					 vctProbe OGRE_SAMPLER_ARG( vctProbeSampler ) );

	finalColour.xyz += pixelData.diffuse.xyz * vctDiffuse.xyz;
	finalColour.xyz += pixelData.specular.xyz * vctSpecular.xyz;
@end

@end
