
@property( vct_num_probes )

@piece( DeclVctTextures )
	@property( syntax == glsl )
		uniform sampler3D vctProbe;
	@end
	@property( syntax == hlsl )
		Texture3D vctProbe				: register(t@value(vctProbe));
		SamplerState vctProbeSampler	: register(s@value(vctProbe));
	@end
	@property( syntax == metal )
		, texture3d<float> vctProbe		[[texture(@value(vctProbe))]]
		, sampler vctProbeSampler		[[sampler(@value(vctProbe))]]
	@end
@end

@piece( DeclVctFuncs )
	/// Generates a TBN matrix when no tangent information is present using
	/// DDX information.
	/// Should only we used as a fallback as the result isn't fully stable due to how DDX works
	/// and due to floating point precision. It is possible for the TBN to change as you zoom-in
	/// to the triangle.
	float3x3 generateTbn( float3 geomNormal, float3 pos )
	{
		float3 tangentX = OGRE_ddx( pos.xyz ).xyz;
		tangentX = normalize( tangentX );

		float3 binormal = cross( geomNormal, tangentX ) ;
		float3x3 TBN = buildFloat3x3( tangentX, binormal, geomNormal );
		return TBN;
	}

	@foreach( 2, n )
		@property( @n == 0 )
			float3 voxelConeTraceDiff
		@else
			float3 voxelConeTraceSpec
		@end
			( VctProbeParams probeParams, float3 posLS, float3 ambient,
			  float3 dirLS, float tanHalfAngle,
			  OGRE_Texture3D_float4 probe
			  OGRE_SAMPLER_ARG_DECL( probeSampler ) )
		{
			float dist = probeParams.vctStartBias;
			float alpha = 0.0;
			float3 color = float3( 0.0, 0.0, 0.0 );

			float diameter = max( probeParams.vctStartBias, 2.0 * tanHalfAngle * dist );

			@property( @n == 0 )
				@property( vct_cone_dirs == 6 )
					float lodLevel	= 0.0;
					float lodStep	= 0.71;
				@else
					float lodLevel	= 1.0;
					float lodStep	= 1.0;
				@end
			@else
				float lodLevel = log2( diameter * probeParams.vctInvStartBias );
			@end
			while( dist < probeParams.vctMaxDistance && alpha < 0.95 )
			{
				float4 scolor = OGRE_SampleLevel( probe, probeSampler,
												  posLS + dist * dirLS,
												  lodLevel );
				float a = (1.0f - alpha);
				color += scolor.xyz * a;
				alpha += a * scolor.w;
				dist += diameter * 0.5f;
				diameter = 2.0 * tanHalfAngle * dist;
				@property( @n == 0 && vct_cone_dirs == 4 )
					lodLevel += lodStep;
				@else
					lodLevel = log2( diameter * probeParams.vctInvStartBias );
				@end
			}

			if( probeParams.vctBlendAmbient != 0 )
				color.xyz = lerp( ambient, color.xyz, min(1.0, alpha / 0.95) );

			return color;
		}
	@end

	float3 toVctProbeSpacePos( float3 pos, VctProbeParams probeParams )
	{
		float3 posLS;
		posLS.x = dot( probeParams.xform_row0.xyzw, float4( pos, 1.0 ) );
		posLS.y = dot( probeParams.xform_row1.xyzw, float4( pos, 1.0 ) );
		posLS.z = dot( probeParams.xform_row2.xyzw, float4( pos, 1.0 ) );
		return posLS;
	}

	float3 toVctProbeSpaceDir( float3 dir, VctProbeParams probeParams )
	{
		float3 dirLS;
		dirLS.x = dot( probeParams.xform_row0.xyz, dir );
		dirLS.y = dot( probeParams.xform_row1.xyz, dir );
		dirLS.z = dot( probeParams.xform_row2.xyz, dir );
		return dirLS;
	}

	#define M_PI 3.141592654f

	void computeVctProbe
	(
		OGRE_INOUT_REF( float3, outDiffuse ), OGRE_INOUT_REF( float4, outSpecular ),
		PixelData pixelData, float3 pos, float3x3 TBN, float3 ambientUpperHemi,
		VctProbeParams probeParams,
		OGRE_Texture3D_float4 probe OGRE_SAMPLER_ARG_DECL( probeSampler )
	)
	{
		float3 posLS = toVctProbeSpacePos( pos + pixelData.geomNormal.xyz * probeParams.vctNormalBias,
										   probeParams );

		if( posLS.x < 0.0 || posLS.x > 1.0 ||
			posLS.y < 0.0 || posLS.y > 1.0 ||
			posLS.z < 0.0 || posLS.z > 1.0 )
		{
			return;
		}

		@property( vct_num_probes > 1 )
			float3 blendv = abs( posLS * 2.0f - 1.0f );
			float blend = saturate( 1.0f - max3( blendv.x, blendv.y, blendv.z ) );
		@else
			float blend = 1.0f;
		@end

		@property( vct_cone_dirs == 6 )
			float3 cone_dirs[6] =
				OGRE_ARRAY_START( float3 )
					float3( 0.0, 0.0, 1.0 ),
					float3( 0.866025, 0.0, 0.5 ),
					float3( 0.267617, 0.823639, 0.5 ),
					float3( -0.700629, 0.509037, 0.5 ),
					float3( -0.700629, -0.509037, 0.5 ),
					float3( 0.267617, -0.823639, 0.5 )
				OGRE_ARRAY_END;

			float coneWeights[6] = OGRE_ARRAY_START( float ) 0.25, 0.15, 0.15, 0.15, 0.15, 0.15 OGRE_ARRAY_END;
			float coneAngleTan = 0.577;
			float minRefTan = 0.0;
		@else
			float3 cone_dirs[4] =
				OGRE_ARRAY_START( float3 )
					float3( 0.707107, 0.0, 0.707107 ),
					float3( 0.0, 0.707107, 0.707107 ),
					float3( -0.707107, 0.0, 0.707107 ),
					float3( 0.0, -0.707107, 0.707107 )
				OGRE_ARRAY_END;

			float coneWeights[4] = OGRE_ARRAY_START( float ) 0.25, 0.25, 0.25, 0.25 OGRE_ARRAY_END;
			float coneAngleTan = 0.98269;
			float minRefTan = 0.1;
		@end

		//Radiance / diffuse
		float3 light = float3( 0.0f, 0.0f, 0.0f );
		for( int i=0; i<@value( vct_cone_dirs ); ++i )
		{
			float3 dir = toVctProbeSpaceDir( mul( TBN, cone_dirs[i] ), probeParams );
			dir = normalize( dir );
			//TODO: There are better values than passBuf.ambientUpperHemi. When VCT probe can be used
			//then we should not apply BRDF_EnvMap and use the values in pixelData.envColourD
			light += coneWeights[i] * voxelConeTraceDiff( probeParams, posLS, ambientUpperHemi, dir,
														  coneAngleTan,
														  probe OGRE_SAMPLER_ARG( probeSampler ) );
		}

		outDiffuse += light * (probeParams.vctBlendFade * blend);

		//Irradiance / specular
		float3 reflVecLS = toVctProbeSpaceDir( pixelData.reflDir, probeParams );
		float specConeAngleTan = max( minRefTan, tan( pixelData.roughness * 0.5f * M_PI * 0.99f ) );
		//TODO: There are better values than passBuf.ambientUpperHemi. When VCT probe can be used
		//then we should not apply BRDF_EnvMap and use the values in pixelData.envColourS
		float3 irrLight = voxelConeTraceSpec( probeParams, posLS, ambientUpperHemi, reflVecLS,
											  specConeAngleTan,
											  probe OGRE_SAMPLER_ARG( probeSampler ) );
		outSpecular += float4( irrLight * (probeParams.vctBlendFade * blend), blend );
	}
@end

@piece( applyVoxelConeTracing )
	@property( !normal_map )
		float3x3 TBN = generateTbn( pixelData.geomNormal, inPs.pos );
	@end

	@property( ambient_hemisphere || ambient_fixed || envmap_scale )
		float3 vctAmbient = passBuf.ambientUpperHemi;
	@else
		float3 vctAmbient = float3( 0, 0, 0 );
	@end

	float3 vctDiffuse = float3( 0, 0, 0 );
	float4 vctSpecular = float4( 0, 0, 0, 0 );
	computeVctProbe( vctDiffuse, vctSpecular, pixelData, inPs.pos, TBN,
					 vctAmbient, passBuf.vctProbeParams,
					 vctProbe OGRE_SAMPLER_ARG( vctProbeSampler ) );

	@property( vct_num_probes > 1 )
		//We've added multiple probes together that are overlapping. Average them
		//based on their influnce (i.e. proximity to probe's center)
		if( vctSpecular.w > 0 )
		{
			float accumProbeInfluenceBorderBlend = 1.0f / vctSpecular.w;
			vctDiffuse.xyz *= accumProbeInfluenceBorderBlend;
			vctSpecular.xyz *= accumProbeInfluenceBorderBlend;
		}
	@end

	finalColour.xyz += pixelData.diffuse.xyz * vctDiffuse.xyz;
	finalColour.xyz += pixelData.specular.xyz * vctSpecular.xyz;
@end

@end
