@property( hlms_lights_area_approx )
@piece( DoAreaApproxLights )
	float3 projectedPosInPlane;

@foreach( hlms_lights_area_approx, n )
	lightDir = passBuf.areaApproxLights[@n].position.xyz - inPs.pos;
	projectedPosInPlane.xyz = inPs.pos - dot( -lightDir.xyz, passBuf.areaApproxLights[@n].direction.xyz ) *
										 passBuf.areaApproxLights[@n].direction.xyz;
	fDistance = length( lightDir );
	if( fDistance <= passBuf.areaApproxLights[@n].attenuation.x
	/*&& dot( -lightDir, passBuf.areaApproxLights[@n].direction.xyz ) > 0*/ @insertpiece( andObjLightMaskCmp ) )
	{
		projectedPosInPlane.xyz -= passBuf.areaApproxLights[@n].position.xyz;
		float3 areaLightBitangent = cross( passBuf.areaApproxLights[@n].tangent.xyz,
											 passBuf.areaApproxLights[@n].direction.xyz );
		float2 invHalfRectSize = float2( passBuf.areaApproxLights[@n].direction.w,
										 passBuf.areaApproxLights[@n].tangent.w );
		//lightUV is in light space, in range [-0.5; 0.5]
		float2 lightUV;
		lightUV.x = dot( projectedPosInPlane.xyz, passBuf.areaApproxLights[@n].tangent.xyz );
		lightUV.y = dot( projectedPosInPlane.xyz, areaLightBitangent );
		lightUV.xy *= invHalfRectSize.xy /*/ sqrt( fDistance )*/;
		//Displace the UV by the normal to account for edge cases when
		//a surface is close and perpendicular to the light. This is fully a hack and
		//the values (e.g. 0.25) is completely eye balled.
		lightUV.xy += float2( dot( passBuf.areaApproxLights[@n].tangent.xyz, nNormal ),
							  dot( areaLightBitangent, nNormal ) ) * 3.75 * invHalfRectSize.xy;
		lightUV.xy = clamp( lightUV.xy, -0.5f, 0.5f );
		float booster = 1.0f - smoothstep( 0.2f, 1.9f, max( abs( lightUV.x ), abs( lightUV.y ) ) );
		booster = 1.0f + booster * 2.25f;
		booster = 1.0f;

		float3 closestPoint = passBuf.areaApproxLights[@n].position.xyz +
				passBuf.areaApproxLights[@n].tangent.xyz * lightUV.x / invHalfRectSize.x +
				areaLightBitangent.xyz * lightUV.y / invHalfRectSize.y;

		float3 lightDir2 = lightDir / fDistance;
		lightDir = closestPoint.xyz - inPs.pos;
		fDistance= length( lightDir );

		float3 toShapeLight = reflect( -viewDir, nNormal );
		float denom = dot( toShapeLight, -passBuf.areaApproxLights[@n].direction.xyz );
		float specCol = 0;
		if( denom > 1e-6f )
		{
			float3 p0l0 = passBuf.areaApproxLights[@n].position.xyz - inPs.pos;
			float t = dot( p0l0, -passBuf.areaApproxLights[@n].direction.xyz ) / denom;
			if( t >= 0 )
			{
				float3 posInShape = inPs.pos.xyz + toShapeLight.xyz * t - passBuf.areaApproxLights[@n].position.xyz;
				float2 reflClipSpace;
				reflClipSpace.x = dot( passBuf.areaApproxLights[@n].tangent.xyz, posInShape );
				reflClipSpace.y = dot( areaLightBitangent, posInShape );
				/*if( abs( reflClipSpace.x * invHalfRectSize.x ) < 0.5f &&
					abs( reflClipSpace.y * invHalfRectSize.y ) < 0.5f )
				{
					specCol = float3(1);
				}*/
				/*if( abs( reflClipSpace.x * invHalfRectSize.x ) < 1.5f &&
					abs( reflClipSpace.y * invHalfRectSize.y ) < 1.5f )*/
				{
//				float2 boxDist = 0.5f / abs( reflClipSpace * invHalfRectSize );
//				specCol = min( boxDist.x, boxDist.y );
				specCol = 0.5f / (length( max( abs( reflClipSpace * invHalfRectSize ) - 0.5f, 0.0f ) ) + 0.5f);
				specCol = min( specCol, 1.0f );
				float areaPower = 2.3075f;
				specCol = pow( specCol, areaPower ) * min( areaPower * areaPower, 1.0f );
				}
			}
		}

		lightDir *= 1.0 / fDistance;
		float fAreaW = dot( lightDir, -passBuf.areaApproxLights[@n].direction.xyz ) * 0.5f + 0.5f;
		//lightDir = (-passBuf.areaApproxLights[@n].direction.xyz + lightDir) * 0.50f;
		//lightDir = lerp( lightDir2, lightDir, fAreaW );
		float globalDot = saturate( dot( -lightDir, passBuf.areaApproxLights[@n].direction.xyz ) );
		tmpColour = BRDF_AreaLightApprox( lightDir, viewDir, NdotV, passBuf.areaApproxLights[@n].diffuse * (1 - specCol),
											/*passBuf.areaApproxLights[@n].specular*/float3(0, 0, 0)
										@property( syntax != glsl )
											, material, nNormal @insertpiece( brdfExtraParams )
										@end
											) * ( globalDot * globalDot ) * booster;
		float atten = 1.0 / (0.5 + (passBuf.areaApproxLights[@n].attenuation.y + passBuf.areaApproxLights[@n].attenuation.z * fDistance) * fDistance );
		finalColour += tmpColour * atten;
		finalColour += passBuf.areaApproxLights[@n].specular.xyz * specCol * atten * ( globalDot * globalDot );
		//finalColour.xyz = float3( dot( lightDir, nNormal ) );
		//finalColour.xyz = float3( lightUV.xy + 0.5f, 0.0f );
		//finalColour.xyz = float3( closestPoint.xy + 0.5f, 0.0f );
	}
@end

@end

@piece( DeclareBRDF_AreaLightApprox )
INLINE float3 BRDF_AreaLightApprox
(
	float3 lightDir, float3 viewDir, float NdotV, float3 lightDiffuse, float3 lightSpecular
	@property( syntax != glsl )
		, Material material, float3 nNormal @insertpiece( brdfExtraParamDefs )
	@end
)
{
	float3 halfWay= normalize( lightDir + viewDir );
	float NdotL = clamp( dot( nNormal, lightDir ), 0.0, 1.0 );
	float NdotH = clamp( dot( nNormal, halfWay ), 0.0, 1.0 );
	float VdotH = clamp( dot( viewDir, halfWay ), 0.0, 1.0 );

	float sqR = ROUGHNESS * ROUGHNESS;

	//Roughness/Distribution/NDF term (GGX)
	//Formula:
	//	Where alpha = roughness
	//	R = alpha^2 / [ PI * [ ( NdotH^2 * (alpha^2 - 1) ) + 1 ]^2 ]
	float f = ( NdotH * sqR - NdotH ) * NdotH + 1.0;
	float R = sqR / (f * f + 1e-6f);

	//Geometric/Visibility term (Smith GGX Height-Correlated)
@property( GGX_height_correlated )
	float Lambda_GGXV = NdotL * sqrt( (-NdotV * sqR + NdotV) * NdotV + sqR );
	float Lambda_GGXL = NdotV * sqrt( (-NdotL * sqR + NdotL) * NdotL + sqR );

	float G = 0.5 / (( Lambda_GGXV + Lambda_GGXL + 1e-6f ) * 3.141592654);
@end @property( !GGX_height_correlated )
	float gL = NdotL * (1-sqR) + sqR;
	float gV = NdotV * (1-sqR) + sqR;
	float G = 1.0 / (( gL * gV + 1e-4f ) * 4 * 3.141592654);
@end

	//Formula:
	//	fresnelS = lerp( (1 - V*H)^5, 1, F0 )
	@insertpiece( FresnelType ) fresnelS = @insertpiece( getSpecularFresnel );

	//We should divide Rs by PI, but it was done inside G for performance
	float3 Rs = ( fresnelS * (R * G) ) * @insertpiece( kS ).xyz * lightSpecular;

	//Diffuse BRDF (*Normalized* Disney, see course_notes_moving_frostbite_to_pbr.pdf
	//"Moving Frostbite to Physically Based Rendering" Sebastien Lagarde & Charles de Rousiers)
	float energyBias	= ROUGHNESS * 0.5;
	float energyFactor	= lerp( 1.0, 1.0 / 1.51, ROUGHNESS );
	float fd90			= energyBias + 2.0 * VdotH * VdotH * ROUGHNESS;
	float lightScatter	= 1.0 + (fd90 - 1.0) * pow( 1.0 - NdotL, 5.0 );
	float viewScatter	= 1.0 + (fd90 - 1.0) * pow( 1.0 - NdotV, 5.0 );

@property( fresnel_separate_diffuse )
	@insertpiece( FresnelType ) fresnelD = @insertpiece( getDiffuseFresnel );
@end @property( !fresnel_separate_diffuse )
	float fresnelD = 1.0f - @insertpiece( getMaxFresnelS );@end

	//We should divide Rd by PI, but it is already included in kD
	float3 Rd = (lightScatter * viewScatter * energyFactor * fresnelD) * @insertpiece( kD ).xyz * lightDiffuse;

	return NdotL * (Rs + Rd);
}
@end

@end
